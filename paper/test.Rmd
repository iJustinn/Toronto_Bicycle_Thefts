```{r, echo=FALSE, warning=FALSE, message=FALSE}
#### Map with Markers ####

# Load necessary libraries
library(dplyr)         # Provides functions for data manipulation.
library(leaflet)       # Enables interactive maps.
library(purrr)         # Contains functional programming tools, used here to walk through data.
library(readr)         # Provides functions to read rectangular data like CSV files.
library(here)          # Helps manage file paths in a more robust way.

# Load your dataset (adjust the file path accordingly)
map_data <- read_csv(here("data", "map_by_neighbourhoods_data.csv"), show_col_types = FALSE)
# Loads the CSV file from the specified path using the 'here()' function for consistent path management.
# 'show_col_types = FALSE' suppresses messages about the data types of each column.

# Modify the data frame, categorizing case_num column
map_data <- map_data %>% 
  mutate(
    mag.level = cut(case_num, c(100, 500, 1000, 1500),
                    labels = c('> 100 & <=500', '>500 & <=1000', '>1000 & <=1500'))
    # Creates a 'mag.level' column that categorizes 'case_num' into three levels based on specified ranges.
  ) %>%
  split(.$mag.level)  # Splits the dataset into a list of data frames by 'mag.level'.

# Initialize the leaflet map
l <- leaflet() %>%
  addProviderTiles(providers$Esri.OceanBasemap)
# Initializes a Leaflet map object and adds a base tile layer from the Esri Ocean Basemap provider.

# Add the markers to the map for each case_num level
names(map_data) %>%
  walk(function(df) {
    l <<- l %>% 
      addMarkers(
        data = map_data[[df]], lng = ~longitude, lat = ~latitude,
        label = ~paste0("Hood: ", hood_name, " | Stolen Place: ", stolen_place, " | Cost: ", cost, " | Status: ", status),
        popup = ~paste0(
          "Hood: ", hood_name, "<br>",
          "Stolen Place: ", stolen_place, "<br>",
          "Cost: ", cost, "<br>",
          "Status: ", status, "<br>",
          "Case in area: ", case_num
        ),
        group = df,
        clusterOptions = markerClusterOptions()
      )
  })
# Iterates over the names of the 'map_data' list (which are the different 'mag.level' categories).
# For each category, it adds markers to the map:
# - `data = map_data[[df]]`: Uses the split data for the current case_num level.
# - `lng = ~longitude, lat = ~latitude`: Sets longitude and latitude for marker placement.
# - `label`: Displays the 'case_num' value when markers are hovered over.
# - `popup`: Displays additional information (hood_num, stolen_place, cost, status, and case_num) when a marker is clicked.
# - `group = df`: Groups the markers by 'mag.level'.
# - `clusterOptions = markerClusterOptions()`: Enables clustering of markers for better visualization.

# Add layer controls and a minimap
l <- l %>%
  addLayersControl(
    overlayGroups = names(map_data),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addMiniMap(tiles = providers$Esri.OceanBasemap, width = 120, height = 80)
# Adds layer controls to allow switching between different 'mag.level' categories on the map.
# Adds a minimap showing a small overview of the area using the Esri Ocean Basemap.

# Display the Map
l
```



```{r, echo=FALSE, warning=FALSE, message=FALSE}
#### Map with Areas ####

# Load necessary libraries
library(dplyr)
library(readr)
library(ggplot2)
library(plotly)
library(sf)
library(crosstalk)
library(here)
library(osmdata)

# Load your dataset (adjust the file path accordingly)
map_data <- read_csv(here("data", "map_by_area_data.csv"), show_col_types = FALSE)

# Get bounding box for Toronto (approximate limits for Toronto)
toronto_bbox <- c(-79.6303856025883, 43.5822069220627, -79.1180336515019, 43.8554571861712)

# Fetch map data from OpenStreetMap (OSM)
toronto_map <- opq(bbox = toronto_bbox) %>%
  add_osm_feature(key = "boundary", value = "administrative") %>%
#  add_osm_feature(key = "highway", value = "primary") %>%
#  add_osm_feature(key = "highway", value = "secondary") %>%
#  add_osm_feature(key = "highway", value = "tertiary") %>%
#  add_osm_feature(key = "highway", value = "residential") %>%
  osmdata_sf()

# Convert map data to Simple Features (sf) objects
streets <- toronto_map$osm_lines

# Generate a similar plot using ggplot2 and plotly
shared_data <- crosstalk::SharedData$new(map_data)

# Create ggplot object with the dataset and Toronto map as a background
ggplot_map <- ggplot() +
  geom_sf(data = streets, color = "lightgray", size = 0.3, alpha = 0.6) +  # Add OSM street map layer
  geom_point(data = shared_data, aes(x = longitude, y = latitude, color = case_num, size = case_num, 
                                     text = paste("Total Cases: ", case_num, " | Area Name: ", area_name))) +
  coord_sf(
    xlim = c(-79.6303856025883, -79.1180336515019),
    ylim = c(43.5822069220627, 43.8554571861712), expand = FALSE
  ) +
  theme_minimal() +
  labs(title = "Toronto Neighbourhood Data by Area", x = "Longitude", y = "Latitude", color = "Number of Cases", size = "Total Cases") +
  theme(
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  scale_color_continuous(labels = scales::comma)

# Convert ggplot object to interactive plotly object
plotly_map <- ggplotly(ggplot_map, tooltip = "text") %>%
  highlight(
    on = "plotly_hover",
    off = "plotly_doubleclick",
    selected = attrs_selected(line = list(color = "black"))
  )

# Display the interactive plotly map
plotly_map
```




